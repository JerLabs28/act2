import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";


import Transformer from "./Transformer";

export default class FlowTransformer extends Transformer {
  constructor(
     rootTransformer,
     tokens,
     isImportsTransformEnabled,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;
  }

  process() {
    if (
      this.rootTransformer.processPossibleArrowParamEnd() ||
      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||
      this.rootTransformer.processPossibleTypeRange()
    ) {
      return true;
    }
    if (this.tokens.matches1(tt._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(tt._export, tt._enum)) {
      this.processNamedExportEnum();
      return true;
    }
    if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {
      this.processDefaultExportEnum();
      return true;
    }
    return false;
  }

  /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      // export
      this.tokens.removeInitialToken();
      const enumName = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum();
      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);
    } else {
      this.tokens.copyToken();
      this.processEnum();
    }
  }

  /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */
  processDefaultExportEnum() {
    // export
    this.tokens.removeInitialToken();
    // default
    this.tokens.removeToken();
    const enumName = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum();
    if (this.isImportsTransformEnabled) {
      this.tokens.appendCode(` exports.default = ${enumName};`);
    } else {
      this.tokens.appendCode(` export default ${enumName};`);
    }
  }

  /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */
  processEnum() {
    // enum E -> cgsOfficeCollabText": "Office-ৰ সৈতে ফাইলসমূহ ছিনক্ৰ’নাইজ কৰি একে সময়তে অন্য ব্যক্তিৰ সৈতে Office ফাইলসমূহত কাম কৰক৷",
  "settingsOfficeSyncConflictsName": "বিবাদ থকা ফাইল এটাৰ দুয়োটা প্ৰতিলিপি ৰখাৰ আগতে সোধক",
  "settingsSyncConflictDescription": "মোক পৰিৱৰ্তনবোৰ এটা ফাইলত একত্ৰিত কৰিবলৈ বা দুয়োটা ফাইল ৰাখিবলৈ বাছনি কৰিবলৈ দিয়ক।",
  "moveWindowLossAversionDialogHeader": "আপুনি ফ'ল্ডাৰ বেক আপ বন্ধ কৰিবলৈ বিচৰাটোত আপুনি নিশ্চিতনে?",
  "placeholdersOptOutWarning": "সকলো OneDrive ফাইল আৰু ফ'ল্ডাৰ এই PC-লৈ ডাউনলোড কৰা হ'ব৷",
  "placeholdersOptOutPrimary": "ফাইলসমূহ অন-ডিমাণ্ড অক্ষম কৰক",
  "giveFeedbackText": "ফীডবেক দিয়ক",
  "dataPrivacySettingsWoTags": "গোপনীয়তা ছেটিংছ",
  "cameraRollBackupCallToActionButtonText": "OneDrive ম’বাইল এপ্প্ লাভ কৰক",
  "cloudFilesUnpinOptionDescriptionV2": "আপুনি খোলা নাই OneDriveৰ ফাইলসমূহ কেৱল আপুনি এই ডিভাইচত খোলালৈকে অনলাইনত উপলব্ধ হ'ব। তাৰ পিছত ফাইলবোৰ ডাউনলোড কৰা হ'ব আৰু অফলাইনত উপলব্ধ হ'ব।",
  "cloudFilesUnpinButtonRnV2": "আপুনি খোলাৰ সময়ত ফাইলসমূহ ডাউনলোড কৰক",
  "cloudF