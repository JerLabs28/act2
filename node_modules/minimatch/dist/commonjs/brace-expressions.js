"use strict";
// translate the various posix character classes into unicode properties
// this works across all unicode locales
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseClass = void 0;
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
  rtl]{direction:rtl}img{border-style:none}form{margin:0;padding:0}legend{margin:0 0 10px;padding:0}code,pre,samp{font-family:Consolas,Menlo,Monaco,"Courier New",monospace;font-size:15px;font-weight:400;line-height:1.333}.win-button,button,button[type=submit],input[type=button],input[type=reset],input[type=submit]{padding-top:2px}input[type=radio],input[type=checkbox]{margin-top:0;margin-bottom:0}html[dir=ltr] input[type=radio],html[dir=ltr] input[type=checkbox]{margin-left:0;margin-right:8px}html[dir=rtl] input[type=radio],html[dir=rtl] input[type=checkbox]{margin-right:0;margin-left:8px}input[type=checkbox]:hover:active::-ms-check,input[type=checkbox]:not:disabled::-ms-check{color:#FFF;background-color:#767676;border-color:#333}select,select:enabled{color:rgba(0,0,0,.6);border-color:rgba(0,0,0,.4);background-color:rgba(255,255,255,.4)}select:enabled:hover,select:hover{border-color:#999;background-color:rgba(255,255,255,.6)}select:active,select:enabled:active,select:enabled:focus,select:focus{border-color:#999}select::-ms-value{padding:4px 8px;margin:0}progress{height:4px}.win-dropdown{margin:0}.win-dropdown:disabled::-ms-expand{color:rgba(255,255,255,.2)}.win-dropdown::-ms-value{padding:0 12px 0 8px;margin:0}input::-ms-clear,input::-ms-reveal{width:auto;height:auto}input::-ms-clear:hover:active,input::-ms-reveal:hover:active{background-color:#0078D7}progress,progress:indeterminate{color:#0078D7}.win-flyout,.win-flyout.win-ui-dark,.win-flyout.win-ui-light{margin-bottom:7px;padding-top:6px;color:#000;background-color:#F2F2F2;border-color:#CCC}.win-flyout h4{margin-top:0;margin-bottom:4px}.win-flyout p{margin-bottom:0}.win-flyout h4+p{margin-